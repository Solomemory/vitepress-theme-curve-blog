---
title: 实现Vue hooks plus的useRequest
tags: [ 前端, Vue ]
categories: [ 技术分享 ]
date: 2025-06-09
description: 详细讲解了如何实现一个类Vue Hooks Plus的useRequest自定义Hook，支持异步请求管理、轮询、生命周期回调等功能，并提供完整代码实现。
articleGPT: 这是一个基于Vue的Hooks实现，用于管理异步请求的状态和生命周期。
references:
  - title: vue-hooks-plus useRequest
    url: https://inhiblabcore.github.io/vue-hooks-plus/zh/hooks/useRequest/guide
---

## 完整代码

```javascript
import { onUnmounted, ref, unref, watchEffect } from "vue";

const defaultOption = {
  defaultParams: undefined, //首次默认执行时的参数
  initialData: undefined, //初始化的数据
  autoRun: false, //在初始化时自动执行请求
  onBefore: undefined, //执行前触发
  onSuccess: undefined, //resolve 时触发
  onError: undefined, //reject 时触发
  onFinally: undefined, //执行完成时触发
  formatResult: undefined, //格式化请求结果
  pollingInterval: 0, //轮询间隔，单位为毫秒。如果值大于 0，则启动轮询模式
};
/**
 * 自定义请求Hook，用于管理异步请求状态和生命周期
 * @param {Function} request - 需要执行的异步请求函数，需返回Promise
 * @param {Object} opt - 配置选项，可覆盖默认配置
 * @param {boolean} [opt.autoRun=false] - 是否自动执行请求
 * @param {*} [opt.initialData] - 首次默认执行时的参数
 * @param {*} [opt.defaultParams] - 初始数据
 * @param {Number} [opt.pollingInterval=0] - 轮询间隔，单位为毫秒。如果值大于 0，则启动轮询模式
 * @param {Function} [opt.onBefore] - 请求前回调
 * @param {Function} [opt.onSuccess] - 请求成功回调
 * @param {Function} [opt.onError] - 请求失败回调
 * @param {Function} [opt.onFinally] - 请求完成回调
 * @param {Function} [opt.formatResult] - 格式化请求结果
 * @returns {Object} 包含状态和方法的管理对象:
 *   - runAsync: 直接返回Promise的请求执行方法
 *   - refreshAsync: 使用记忆参数重新执行runAsync方法
 *   - data: 响应式请求结果数据
 *   - loading: 响应式加载状态
 *   - run: 自动处理状态的生命周期请求方法
 *   - error: 响应式错误对象
 *   - params: 响应式请求参数
 *   - refresh: 参数记忆式请求刷新方法
 */
export const useRequest = (request, opt) => {
  // 合并默认配置和用户配置
  const option = Object.assign({}, defaultOption, opt);
  // 响应式状态定义
  const loading = ref(false);
  const data = ref(option.initialData);
  const error = ref();
  const params = ref();
  let timer = null;
  // 核心请求方法，包含完整的生命周期处理
  const run = async (...args) => {
    option.onBefore && option.onBefore(args);
    params.value = args;
    loading.value = true;
    try {
      const res = await request(...args);
      data.value = res;
      option.onSuccess && option.onSuccess(data.value);
      option.formatResult && (data.value = option.formatResult(res));
    } catch (err) {
      option.onError && option.onError(err, args);
      error.value = err;
      console.log(err);
    } finally {
      option.onFinally && option.onFinally(args, data.value);
      loading.value = false;
      // 新增轮询逻辑
      if (unref(option.pollingInterval)) {
        stopPolling();
        timer = setTimeout(() => {
          run(...(params.value || []));
        }, unref(option.pollingInterval));
      }
    }
  };
  // 简化版请求方法，直接返回原始Promise
  const runAsync = async (...args) => {
    option.onBefore && option.onBefore(args);
    params.value = args;
    loading.value = true;
    try {
      return await request(...args);
    } catch (err) {
      option.onError && option.onError(err, args);
      error.value = err;
    } finally {
      option.onFinally && option.onFinally(args, data.value);
      loading.value = false;
      // 新增轮询逻辑
      if (unref(option.pollingInterval)) {
        stopPolling();
        timer = setTimeout(() => {
          run(...(params.value || []));
        }, unref(option.pollingInterval));
      }
    }
  };
  // 使用记忆参数重新发起请求
  const refresh = () => {
    run(...(params.value || []));
  };
  // 使用记忆参数重新发起请求，返回原始Promise
  const refreshAsync = async () => {
    return await runAsync(...(params.value || []));
  };
  const stopPolling = () => {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  };
  watchEffect(() => {
    if (!unref(option.pollingInterval)) {
      stopPolling();
    }
  });
  // 自动执行逻辑
  option.autoRun && run(option.defaultParams);
  onUnmounted(() => {
    stopPolling();
  });
  return {
    refreshAsync,
    runAsync,
    data,
    loading,
    run,
    error,
    params,
    refresh,
    stopPolling,
  };
};
```
